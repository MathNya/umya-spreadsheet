use std::{
    cmp::Ordering,
    io::{
        self,
        Write,
    },
    path::Path,
};

use aes::{
    Aes256,
    cipher::{
        BlockDecryptMut,
        BlockEncryptMut,
        KeyIvInit,
        block_padding::NoPadding,
    },
};
use base64::{
    Engine as _,
    engine::general_purpose::STANDARD,
};
use byteorder::{
    ByteOrder,
    LittleEndian,
};
use cbc::{
    Decryptor,
    Encryptor,
};
use hmac::{
    Hmac,
    Mac,
};
use quick_xml::{
    Writer,
    events::{
        BytesDecl,
        Event,
    },
};
use rand::Rng;
use sha2::{
    Digest,
    Sha512,
};

use super::const_str::{
    CERTIFICATE_NS,
    ENCRYPTION_NS,
    PASSWORD_NS,
};
use crate::{
    structs::{
        SheetProtection,
        WorkbookProtection,
    },
    writer::driver::{
        write_end_tag,
        write_new_line,
        write_start_tag,
    },
};

type Aes256CbcEnc = Encryptor<Aes256>;
type Aes256CbcDec = Decryptor<Aes256>;

#[rustfmt::skip]
pub(crate) mod constants {
    /// Constants used in the encryption process
    pub const ENCRYPTION_INFO_PREFIX: [u8; 8] = [
        0x04, 0x00, 0x04, 0x00, 
        0x40, 0x00, 0x00, 0x00
    ]; // Version and reserved bytes

    pub const PACKAGE_ENCRYPTION_CHUNK_SIZE: usize = 4096;
    pub const PACKAGE_OFFSET: usize = 8; // First 8 bytes are the size of the stream

    // Block keys used in various stages of encryption
    pub const BLOCK_KEYS_DATA_INTEGRITY_HMAC_KEY: [u8; 8] = [
        0x5f, 0xb2, 0xad, 0x01,
        0x0c, 0xb9, 0xe1, 0xf6,
    ];

    pub const BLOCK_KEYS_DATA_INTEGRITY_HMAC_VALUE: [u8; 8] = [
        0xa0, 0x67, 0x7f, 0x02,
        0xb2, 0x2c, 0x84, 0x33,
    ];

    pub const BLOCK_KEYS_KEY: [u8; 8] = [
        0x14, 0x6e, 0x0b, 0xe7,
        0xab, 0xac, 0xd0, 0xd6,
    ];

    pub const BLOCK_VERIFIER_HASH_INPUT: [u8; 8] = [
        0xfe, 0xa7, 0xd2, 0x76,
        0x3b, 0x4b, 0x9e, 0x79,
    ];

    pub const BLOCK_VERIFIER_HASH_VALUE: [u8; 8] = [
        0xd7, 0xaa, 0x0f, 0x6d,
        0x30, 0x61, 0x34, 0x4e,
    ];

    // Package parameters
    pub const PACKAGE_BLOCK_SIZE: usize = 16;
    pub const PACKAGE_CIPHER_ALGORITHM: &str = "AES";
    pub const PACKAGE_CIPHER_CHAINING: &str = "ChainingModeCBC";
    pub const PACKAGE_HASH_ALGORITHM: &str = "SHA512";
    pub const PACKAGE_HASH_SIZE: usize = 64;
    pub const PACKAGE_KEY_BITS: usize = PACKAGE_KEY_LENGTH * 8;
    pub const PACKAGE_KEY_LENGTH: usize = 32;

    // Key parameters
    pub const KEY_BITLENGTH: usize = 256;
    pub const KEY_BLOCK_SIZE: usize = 16;
    pub const KEY_CIPHER_ALGORITHM: &str = "AES";
    pub const KEY_CIPHER_CHAINING: &str = "ChainingModeCBC";
    pub const KEY_HASH_ALGORITHM: &str = "SHA-512";
    pub const KEY_HASH_SIZE: usize = 64;
    pub const KEY_SPIN_COUNT: usize = 100_000;
}

/// Generates a mutable byte array of the specified size and fills it with
/// cryptographically secure random bytes using `rand::thread_rng`.
///
/// # Parameters
///
/// - `$var_name`: The identifier for the byte array variable to be created.
/// - `$size`: The size of the byte array in bytes.
///
/// # Examples
///
/// ```rust
/// use rand::Rng;
///
/// // Define the macro
/// macro_rules! generate_random_bytes {
///     ($var_name:ident, $size:expr) => {
///         let mut $var_name = [0u8; $size];
///         rand::thread_rng().fill(&mut $var_name[..]);
///     };
/// }
///
/// // Use the macro to generate a 16-byte random salt
/// generate_random_bytes!(salt, 16);
/// assert_eq!(salt.len(), 16);
///
/// // Use the macro to generate a 32-byte random key
/// generate_random_bytes!(key, 32);
/// assert_eq!(key.len(), 32);
/// ```
///
/// # Notes
///
/// - This macro creates a mutable byte array with the specified name and size.
/// - The random bytes are generated using the `thread_rng` from the `rand`
///   crate, which provides a fast, thread-local, secure random number
///   generator.
/// - Suitable for generating cryptographic keys, salts, nonces, and other
///   random data.
/// - The macro does not return the byte array; it defines it in the current
///   scope.
/// - Ensure that the generated byte arrays are handled securely and not exposed
///   unintentionally.
macro_rules! generate_random_bytes {
    ($var_name:ident, $size:expr) => {
        let mut $var_name = [0u8; $size];
        rand::thread_rng().fill(&mut $var_name[..]);
    };
}

/// Encrypts the sheet protection using the provided password.
///
/// Updates the `sheet_protection` object with the algorithm name, salt value,
/// spin count, and hash value.
///
/// # Parameters
///
/// - `password`: The password to use for encryption.
/// - `sheet_protection`: The `SheetProtection` object to update with encryption
///   details.
#[allow(clippy::cast_possible_truncation)]
pub fn encrypt_sheet_protection(password: &str, sheet_protection: &mut SheetProtection) {
    generate_random_bytes!(salt, 16);

    // Convert the password into a hash
    let key = convert_password_to_hash(password, &salt, constants::KEY_SPIN_COUNT);

    // Encode the salt and hash value in base64
    let salt_value_str = STANDARD.encode(salt);
    let hash_value_str = STANDARD.encode(&key);

    // Update the sheet_protection object
    sheet_protection.set_algorithm_name(constants::KEY_HASH_ALGORITHM);
    sheet_protection.set_salt_value(salt_value_str);
    sheet_protection.set_spin_count(constants::KEY_SPIN_COUNT as u32);
    sheet_protection.set_hash_value(hash_value_str);
    sheet_protection.remove_password_raw();
}

/// Encrypts the workbook protection using the provided password.
///
/// Updates the `workbook_protection` object with the algorithm name, salt
/// value, spin count, and hash value.
///
/// # Parameters
///
/// - `password`: The password to use for encryption.
/// - `workbook_protection`: The `WorkbookProtection` object to update with
///   encryption details.
#[allow(clippy::cast_possible_truncation)]
pub fn encrypt_workbook_protection(password: &str, workbook_protection: &mut WorkbookProtection) {
    generate_random_bytes!(salt, 16);

    // Convert the password into a hash
    let key = convert_password_to_hash(password, &salt, constants::KEY_SPIN_COUNT);

    // Encode the salt and hash value in base64
    let salt_value_str = STANDARD.encode(salt);
    let hash_value_str = STANDARD.encode(&key);

    // Update the workbook_protection object
    workbook_protection.set_workbook_algorithm_name(constants::KEY_HASH_ALGORITHM);
    workbook_protection.set_workbook_salt_value(salt_value_str);
    workbook_protection.set_workbook_spin_count(constants::KEY_SPIN_COUNT as u32);
    workbook_protection.set_workbook_hash_value(hash_value_str);
    workbook_protection.remove_workbook_password_raw();
}

/// Encrypts the revisions protection using the provided password.
///
/// This function generates a random salt, derives a key from the password using
/// SHA-512, and updates the workbook protection settings with the encrypted
/// values.
///
/// # Arguments
///
/// * `password` - The password string to use for encryption
/// * `workbook_protection` - Mutable reference to the `WorkbookProtection`
///   object to update
#[allow(clippy::cast_possible_truncation)]
pub fn encrypt_revisions_protection(password: &str, workbook_protection: &mut WorkbookProtection) {
    generate_random_bytes!(salt, 16);

    // Convert the password into a hash
    let key = convert_password_to_hash(password, &salt, constants::KEY_SPIN_COUNT);

    // Encode the salt and hash value in base64
    let salt_value_str = STANDARD.encode(salt);
    let hash_value_str = STANDARD.encode(&key);

    // Update the workbook_protection object
    workbook_protection.set_revisions_algorithm_name(constants::KEY_HASH_ALGORITHM);
    workbook_protection.set_revisions_salt_value(salt_value_str);
    workbook_protection.set_revisions_spin_count(constants::KEY_SPIN_COUNT as u32);
    workbook_protection.set_revisions_hash_value(hash_value_str);
    workbook_protection.remove_revisions_password_raw();
}

/// Concatenates multiple byte slices into a single vector.
///
/// Takes a slice of byte slices and combines them sequentially into a single
/// `Vec<u8>`. Pre-allocates the exact required capacity to avoid reallocations.
#[allow(dead_code)]
fn buffer_concat(buffers: &[&[u8]]) -> Vec<u8> {
    // Calculate the total length of the resulting vector.
    let total_length = buffers.iter().map(|buffer| buffer.len()).sum();
    // Preallocate the vector with the total length.
    let mut result: Vec<u8> = Vec::with_capacity(total_length);
    // Extend the vector with each buffer.
    for buffer in buffers {
        result.extend_from_slice(buffer);
    }
    result
}

/// Encrypts the given data and writes it to a specified file.
///
/// This function performs the following steps:
/// 1. Generates random bytes for various cryptographic keys and salts.
/// 2. Encrypts the data using a specified package cipher algorithm (AES).
/// 3. Generates and encrypts an HMAC key and its corresponding value for data
///    integrity.
/// 4. Converts the provided password into a key using a key derivation
///    function.
/// 5. Encrypts the derived key and generates a verifier hash input and value,
///    both of which are also encrypted.
/// 6. Constructs an XML structure containing encryption information.
/// 7. Creates a compound file and writes the encrypted data and metadata to it.
///
/// # Parameters
///
/// - `filepath`: A reference to the path where the encrypted data will be
///   saved. This can be any type that implements the `AsRef<Path>` trait.
/// - `data`: A byte slice containing the data to be encrypted.
/// - `password`: A string slice representing the password used for key
///   derivation.
///
/// # Errors
///
/// This function may return errors related to file I/O or cryptographic
/// operations. Ensure to handle these errors appropriately in your application.
///
/// # Panics
///
/// This function may panic if:
/// - The underlying file operations fail (e.g., if the file cannot be created
///   or written to).
/// - Any cryptographic operation fails, such as key generation or encryption,
///   due to invalid parameters or internal errors.
///
/// # Example
///
/// ```
/// let data = b"Sensitive data to encrypt";
/// let password = "securepassword";
/// let filepath = "encrypted_data.bin";
///
/// encrypt(&filepath, data, password);
/// ```
///
/// # Note
///
/// The encryption process involves multiple cryptographic operations, including
/// key generation, HMAC creation, and data encryption. Ensure that the password
/// used is strong and kept secure.
pub fn encrypt<P: AsRef<Path>>(filepath: &P, data: &[u8], password: &str) {
    generate_random_bytes!(hmac_key, 64);
    generate_random_bytes!(key_salt, 16);
    generate_random_bytes!(package_key, 32);
    generate_random_bytes!(package_salt, 16);
    generate_random_bytes!(verifier_hash_input, 16);

    // Encrypt the package
    let encrypted_package =
        crypt_package(true, constants::PACKAGE_BLOCK_SIZE, &package_salt, &package_key, data);

    // Generate HMAC key and encrypt it
    let hmac_key_iv = create_iv(
        &package_salt,
        constants::PACKAGE_BLOCK_SIZE,
        &constants::BLOCK_KEYS_DATA_INTEGRITY_HMAC_KEY,
    );
    let encrypted_hmac_key = crypt(true, &package_key, &hmac_key_iv, &hmac_key).unwrap();

    // Generate HMAC value and encrypt it
    let hmac_value = hmac(&hmac_key, &[&encrypted_package]);
    let hmac_value_iv = create_iv(
        &package_salt,
        constants::PACKAGE_BLOCK_SIZE,
        &constants::BLOCK_KEYS_DATA_INTEGRITY_HMAC_VALUE,
    );
    let encrypted_hmac_value = crypt(true, &package_key, &hmac_value_iv, &hmac_value).unwrap();

    // Convert the password to a key
    let key = convert_password_to_key(
        password,
        &key_salt,
        constants::KEY_SPIN_COUNT,
        constants::KEY_BITLENGTH,
        &constants::BLOCK_KEYS_KEY,
    );
    let encrypted_key_value = crypt(true, &key, &key_salt, &package_key).unwrap();

    // Generate verifier hash input and encrypt it
    let verifier_hash_input_key = convert_password_to_key(
        password,
        &key_salt,
        constants::KEY_SPIN_COUNT,
        constants::KEY_BITLENGTH,
        &constants::BLOCK_VERIFIER_HASH_INPUT,
    );
    let encrypted_verifier_hash_input =
        crypt(true, &verifier_hash_input_key, &key_salt, &verifier_hash_input).unwrap();

    // Generate verifier hash value and encrypt it
    let verifier_hash_value = hash_concatenated(&[&verifier_hash_input]);
    let verifier_hash_value_key = convert_password_to_key(
        password,
        &key_salt,
        constants::KEY_SPIN_COUNT,
        constants::KEY_BITLENGTH,
        &constants::BLOCK_VERIFIER_HASH_VALUE,
    );
    let encrypted_verifier_hash_value =
        crypt(true, &verifier_hash_value_key, &key_salt, &verifier_hash_value).unwrap();

    // Build the encryption info XML data
    let encryption_info_buffer = build_encryption_info(
        &package_salt,
        &encrypted_hmac_key,
        &encrypted_hmac_value,
        &key_salt,
        &encrypted_verifier_hash_input,
        &encrypted_verifier_hash_value,
        &encrypted_key_value,
    );

    // Create compound file and write streams
    let mut comp = cfb::create(filepath).unwrap();
    {
        let mut stream_info = comp.create_stream("EncryptionInfo").unwrap();
        stream_info.write_all(&encryption_info_buffer).unwrap();
    }
    {
        let mut stream_package = comp.create_stream("EncryptedPackage").unwrap();
        stream_package.write_all(&encrypted_package).unwrap();
    }
}

/// Encrypts or decrypts package data using AES-256 in CBC mode.
///
/// # Parameters
/// - `encrypt`: Whether to encrypt (true) or decrypt (false) the data
/// - `block_size`: Size of encryption blocks in bytes
/// - `salt`: Salt value for IV generation
/// - `key`: Encryption/decryption key
/// - `input`: Data to encrypt/decrypt
///
/// # Returns
/// A vector containing the encrypted/decrypted data. For encryption, includes
/// an 8-byte length prefix. For decryption, output is truncated to the original
/// length.
#[allow(clippy::cast_possible_truncation)]
fn crypt_package(
    encrypt: bool,
    block_size: usize,
    salt: &[u8],
    key: &[u8],
    input: &[u8],
) -> Vec<u8> {
    let mut output_chunks: Vec<Vec<u8>> = Vec::new();
    let offset = if encrypt { 0 } else { constants::PACKAGE_OFFSET };

    // Process the package in chunks
    let mut i: usize = 0;
    let mut end = 0;
    while end < input.len() {
        let start = end;
        end = (start + constants::PACKAGE_ENCRYPTION_CHUNK_SIZE).min(input.len());

        // Get the next chunk
        let mut input_chunk = input[start + offset..end + offset].to_vec();

        // Pad the chunk if it is not a multiple of the block size
        let remainder = input_chunk.len() % block_size;
        if remainder > 0 {
            input_chunk.extend(vec![0u8; block_size - remainder]);
        }

        // Create the initialization vector (IV) for this chunk
        let block_key_buffer = create_uint32_le_buffer(i as u32, None);
        let iv = create_iv(salt, block_size, &block_key_buffer);

        // Encrypt or decrypt the chunk
        let output_chunk = crypt(encrypt, key, &iv, &input_chunk).unwrap();
        output_chunks.push(output_chunk);

        i += 1;
    }

    // Concatenate all output chunks
    let mut output = output_chunks.concat();

    if encrypt {
        // Prepend the length of the package in the first 8 bytes
        let input_len = input.len() as u32;
        let length_buffer = create_uint32_le_buffer(input_len, Some(constants::PACKAGE_OFFSET));
        output = [length_buffer, output].concat();
    } else {
        // Truncate the output to the size specified in the prefix
        let length = LittleEndian::read_u32(&input[0..4]) as usize;
        output.truncate(length);
    }

    output
}

/// Performs AES-256-CBC encryption or decryption on input data.
///
/// # Arguments
/// * `encrypt` - If true, encrypts the data. If false, decrypts the data
/// * `key` - 256-bit encryption/decryption key
/// * `iv` - Initialization vector for CBC mode
/// * `input` - Data to be encrypted/decrypted
///
/// # Returns
/// * `Ok(Vec<u8>)` - Encrypted/decrypted data
/// * `Err(String)` - Error message if operation fails
fn crypt(encrypt: bool, key: &[u8], iv: &[u8], input: &[u8]) -> Result<Vec<u8>, String> {
    match key.len() * 8 {
        256 => {
            if encrypt {
                // Encrypt the input data
                let cipher = Aes256CbcEnc::new_from_slices(key, iv)
                    .map_err(|e| format!("Error creating cipher: {e}"))?;
                let mut buffer = input.to_vec();
                cipher
                    .encrypt_padded_mut::<NoPadding>(&mut buffer, input.len())
                    .map_err(|e| format!("Encryption error: {e}"))?;
                Ok(buffer)
            } else {
                // Decrypt the input data
                let cipher = Aes256CbcDec::new_from_slices(key, iv)
                    .map_err(|e| format!("Error creating cipher: {e}"))?;
                let mut buffer = input.to_vec();
                cipher
                    .decrypt_padded_mut::<NoPadding>(&mut buffer)
                    .map_err(|e| format!("Decryption error: {e}"))?;
                Ok(buffer)
            }
        }
        _ => Err("Key size not supported!".to_string()),
    }
}

/// Calculates an HMAC using SHA-512 over concatenated input buffers.
///
/// # Arguments
/// * `key` - The key used for HMAC calculation
/// * `buffers` - Slice of byte slices to be concatenated and hashed
///
/// # Returns
/// A vector containing the calculated HMAC bytes
fn hmac(key: &[u8], buffers: &[&[u8]]) -> Vec<u8> {
    let mut mac = Hmac::<Sha512>::new_from_slice(key).unwrap();
    for buffer in buffers {
        mac.update(buffer);
    }
    mac.finalize().into_bytes().to_vec()
}

/// Creates an IV by hashing the salt value and block key together.
/// The resulting hash is adjusted to match the specified block size
/// by either padding with zeros or truncating.
///
/// # Arguments
/// * `salt_value` - Salt value to use in hash
/// * `block_size` - Target size for the IV in bytes
/// * `block_key` - Block key to use in hash
///
/// # Returns
/// A vector containing the IV adjusted to the block size
fn create_iv(salt_value: &[u8], block_size: usize, block_key: &[u8]) -> Vec<u8> {
    // Hash the salt value and block key together
    let mut iv = hash_concatenated(&[salt_value, block_key]);

    // Adjust the IV length to match the block size
    match iv.len().cmp(&block_size) {
        Ordering::Less => {
            // Pad with zeros if IV is shorter than block size
            iv.resize(block_size, 0);
        }
        Ordering::Greater => {
            // Truncate if IV is longer than block size
            iv.truncate(block_size);
        }
        Ordering::Equal => {}
    }

    iv
}

/// Takes a slice of byte slices and computes their SHA-512 hash.
/// Concatenates all input buffers and processes them sequentially.
/// Returns the resulting hash as a vector of bytes.
fn hash_concatenated(buffers: &[&[u8]]) -> Vec<u8> {
    let mut hasher = Sha512::new();

    for buffer in buffers {
        hasher.update(buffer);
    }

    hasher.finalize().to_vec()
}

/// Generates a cryptographic key from a password using SHA-512 hashing.
///
/// # Arguments
/// * `password` - Password string to convert
/// * `salt` - Salt bytes for key derivation
/// * `spin_count` - Number of iterations for key strengthening
/// * `key_bits` - Desired key length in bits
/// * `block_key` - Additional key material for final hash
///
/// # Returns
/// A vector containing the derived key bytes, truncated or padded to match
/// `key_bits` length
#[allow(clippy::cast_possible_truncation)]
fn convert_password_to_key(
    password: &str,
    salt: &[u8],
    spin_count: usize,
    key_bits: usize,
    block_key: &[u8],
) -> Vec<u8> {
    // Convert password to UTF-16LE bytes
    let password_bytes: Vec<u8> = password.encode_utf16().flat_map(u16::to_le_bytes).collect();

    let mut hasher = Sha512::new();

    hasher.update(salt);
    hasher.update(&password_bytes);

    let mut key = hasher.finalize();

    // Iterate spin_count times
    for i in 0..spin_count {
        let i_bytes = (i as u32).to_le_bytes();
        let mut hasher = Sha512::new();
        hasher.update(i_bytes);
        hasher.update(key);
        key = hasher.finalize();
    }

    let mut hasher = Sha512::new();
    hasher.update(key);
    hasher.update(block_key);
    let mut key = hasher.finalize().to_vec();

    // Truncate or pad the key to the desired length
    let key_bytes = key_bits / 8;
    match key.len().cmp(&key_bytes) {
        Ordering::Less => {
            // Pad with zeros
            key.resize(key_bytes, 0);
            key
        }
        Ordering::Greater => key[..key_bytes].to_vec(),
        Ordering::Equal => key,
    }
}

/// Generates a cryptographic hash of a password using SHA-512.
///
/// # Arguments
/// * `password` - The password string to hash
/// * `salt` - The salt bytes to use in hashing
/// * `spin_count` - Number of iterations for the hash function
///
/// # Returns
/// A vector containing the final hash value
#[allow(clippy::cast_possible_truncation)]
fn convert_password_to_hash(password: &str, salt: &[u8], spin_count: usize) -> Vec<u8> {
    // Convert password to UTF-16LE bytes
    let password_bytes: Vec<u8> = password.encode_utf16().flat_map(u16::to_le_bytes).collect();

    let mut hasher = Sha512::new();
    hasher.update(salt);
    hasher.update(password_bytes);

    // Iterate spin_count times
    for i in 0..spin_count {
        let i_bytes = (i as u32).to_le_bytes();
        hasher.update(i_bytes);
    }

    hasher.finalize().to_vec()
}

/// Creates a little-endian byte buffer from a `u32` value.
///
/// If `buffer_size` is provided and greater than 4, the buffer is padded with
/// zeros to match the specified size.
///
/// # Parameters
/// - `value`: The `u32` value to convert.
/// - `buffer_size`: Optional desired size of the buffer.
///
/// # Returns
/// A `Vec<u8>` containing the little-endian bytes of `value`, optionally padded
/// with zeros.
fn create_uint32_le_buffer(value: u32, buffer_size: Option<usize>) -> Vec<u8> {
    let mut buffer = value.to_le_bytes().to_vec();
    if let Some(size) = buffer_size.filter(|&s| s > 4) {
        buffer.resize(size, 0);
    }
    buffer
}

/// Constructs the encryption info XML data for document protection.
///
/// # Arguments
/// * `package_salt` - Salt value for package encryption
/// * `data_integrity_encrypted_hmac_key` - Encrypted HMAC key for data
///   integrity
/// * `data_integrity_encrypted_hmac_value` - Encrypted HMAC value for data
///   integrity
/// * `key_salt` - Salt value for key encryption
/// * `key_encrypted_verifier_hash_input` - Encrypted verifier hash input
/// * `key_encrypted_verifier_hash_value` - Encrypted verifier hash value
/// * `key_encrypted_key_value` - Encrypted key value
///
/// # Returns
/// A vector of bytes containing the encryption info XML prefixed with the
/// standard header
fn build_encryption_info(
    package_salt: &[u8],
    data_integrity_encrypted_hmac_key: &[u8],
    data_integrity_encrypted_hmac_value: &[u8],
    key_salt: &[u8],
    key_encrypted_verifier_hash_input: &[u8],
    key_encrypted_verifier_hash_value: &[u8],
    key_encrypted_key_value: &[u8],
) -> Vec<u8> {
    let mut writer = Writer::new(io::Cursor::new(Vec::new()));
    // XML header
    writer.write_event(Event::Decl(BytesDecl::new("1.0", Some("UTF-8"), Some("yes")))).unwrap();
    write_new_line(&mut writer);

    // Start encryption element
    write_start_tag(
        &mut writer,
        "encryption",
        vec![("xmlns", ENCRYPTION_NS), ("xmlns:p", PASSWORD_NS), ("xmlns:c", CERTIFICATE_NS)],
        false,
    );

    // keyData element
    write_start_tag(
        &mut writer,
        "keyData",
        vec![
            ("saltSize", &package_salt.len().to_string()),
            ("blockSize", &constants::PACKAGE_BLOCK_SIZE.to_string()),
            ("keyBits", &constants::PACKAGE_KEY_BITS.to_string()),
            ("hashSize", &constants::PACKAGE_HASH_SIZE.to_string()),
            ("cipherAlgorithm", constants::PACKAGE_CIPHER_ALGORITHM),
            ("cipherChaining", constants::PACKAGE_CIPHER_CHAINING),
            ("hashAlgorithm", constants::PACKAGE_HASH_ALGORITHM),
            ("saltValue", &STANDARD.encode(package_salt)),
        ],
        true,
    );

    // dataIntegrity element
    write_start_tag(
        &mut writer,
        "dataIntegrity",
        vec![
            ("encryptedHmacKey", &STANDARD.encode(data_integrity_encrypted_hmac_key)),
            ("encryptedHmacValue", &STANDARD.encode(data_integrity_encrypted_hmac_value)),
        ],
        true,
    );

    // keyEncryptors element
    write_start_tag(&mut writer, "keyEncryptors", vec![], false);

    // keyEncryptor element
    write_start_tag(&mut writer, "keyEncryptor", vec![("uri", PASSWORD_NS)], false);

    // p:encryptedKey element
    write_start_tag(
        &mut writer,
        "p:encryptedKey",
        vec![
            ("spinCount", &constants::KEY_SPIN_COUNT.to_string()),
            ("saltSize", &key_salt.len().to_string()),
            ("blockSize", &constants::KEY_BLOCK_SIZE.to_string()),
            ("keyBits", &constants::KEY_BITLENGTH.to_string()),
            ("hashSize", &constants::KEY_HASH_SIZE.to_string()),
            ("cipherAlgorithm", constants::KEY_CIPHER_ALGORITHM),
            ("cipherChaining", constants::KEY_CIPHER_CHAINING),
            ("hashAlgorithm", constants::KEY_HASH_ALGORITHM),
            ("saltValue", &STANDARD.encode(key_salt)),
            ("encryptedVerifierHashInput", &STANDARD.encode(key_encrypted_verifier_hash_input)),
            ("encryptedVerifierHashValue", &STANDARD.encode(key_encrypted_verifier_hash_value)),
            ("encryptedKeyValue", &STANDARD.encode(key_encrypted_key_value)),
        ],
        true,
    );

    // Close tags
    write_end_tag(&mut writer, "keyEncryptor");
    write_end_tag(&mut writer, "keyEncryptors");
    write_end_tag(&mut writer, "encryption");

    let result = writer.into_inner().into_inner().clone();

    // Combine the constants::ENCRYPTION_INFO_PREFIX and the XML data
    [constants::ENCRYPTION_INFO_PREFIX.to_vec(), result].concat()
}

#[cfg(test)]
mod tests {
    use std::{
        fs::File,
        io::Read,
    };

    use hex_literal::hex;

    use super::*;

    #[test]
    fn test_encrypt() {
        let mut file = File::open("./tests/test_files/aaa.xlsx").unwrap();
        let mut data = Vec::new();
        file.read_to_end(&mut data).unwrap();

        let password = "password";

        // Package parameters
        let package_key = hex!("cdf9defae2480933c503350e16334453d1cb8348bb2fea585db7f9e1f78fe9bf");
        let package_salt = hex!("4c251b321d85cecfcb6d952ba6d81846");

        // Key parameters
        let key_salt = hex!("3aa973eec73c98c4710021730ef5b513");

        // Encrypted package
        let encrypted_package =
            crypt_package(true, constants::PACKAGE_BLOCK_SIZE, &package_salt, &package_key, &data);

        // HMAC key
        let hmac_key = hex!(
            "4c6e4db6d9a60e5d41c3ca639a682aaa71da7437202fe92ec5d814bd1e9e4e6a"
            "831aee889eae3bc18bc1bebedae1f73393fddfffd0a0b6c557485fefcdb5e98b"
        );

        let hmac_key_iv = create_iv(
            &package_salt,
            constants::PACKAGE_BLOCK_SIZE,
            &constants::BLOCK_KEYS_DATA_INTEGRITY_HMAC_KEY,
        );
        assert_eq!(hmac_key_iv, hex!("ba1bf00eed82b07ee65e574eb1f46043"));

        let encrypted_hmac_key = crypt(true, &package_key, &hmac_key_iv, &hmac_key).unwrap();
        assert_eq!(
            encrypted_hmac_key,
            hex!(
                "b32b1cdc4ac1af244377c1eb57efd31a819f555a7204adcc0cfe364b394bbdb0
                 86a8daef4f4c512d52e3db6a54b1d45e1dd1dbfa3ddacc29fe35449ba5225dc7"
            )
        );

        // HMAC value
        let hmac_value = hmac(&hmac_key, &[&encrypted_package]);
        // Uncomment the following lines to check the HMAC value
        // let converted = encode_hex(&hmac_value);
        // assert_eq!(&converted,
        // "41748c1ed0bcbbc46301a0a21e00747b6fafaa52ddbe4952a77a399ed4514b40c9b7e59f1c52c4cc72881794435336cc6e42fef4498245575bb9c2343480773f"
        // );

        let hmac_value_iv = create_iv(
            &package_salt,
            constants::PACKAGE_BLOCK_SIZE,
            &constants::BLOCK_KEYS_DATA_INTEGRITY_HMAC_VALUE,
        );
        assert_eq!(hmac_value_iv, hex!("088385b871292e7ed8414f173c5b6622"));

        let encrypted_hmac_value = crypt(true, &package_key, &hmac_value_iv, &hmac_value).unwrap();
        // Uncomment the following lines to check the encrypted HMAC value
        // let converted = encode_hex(&encrypted_hmac_value);
        // assert_eq!(&converted,
        // "1f6fc2877101ac12ccee6dbb0e5ea2556cc61c2c532b89ffc701fd16c5078e7e8264034ded6dc00469039f706fce12747db817574f13b49d18e914fdf4e3e93b"
        // );

        // Key
        let key = convert_password_to_key(
            password,
            &key_salt,
            constants::KEY_SPIN_COUNT,
            constants::KEY_BITLENGTH,
            &constants::BLOCK_KEYS_KEY,
        );
        assert_eq!(key, hex!("8d5869311b1c1fdb59a1de6fe1e6f2ce7dccd4deb198a6dfb1f7fb55bc03487d"));

        let encrypted_key_value = crypt(true, &key, &key_salt, &package_key).unwrap();
        assert_eq!(
            encrypted_key_value,
            hex!("5017ddc6146e56dfbf76734b3e99b80f36a4c9a2e9eb21fe77695f73850cc452")
        );

        // Verifier hash input
        let verifier_hash_input = hex!("8f54777cba87efa55ea2db8399873815");
        let verifier_hash_input_key = convert_password_to_key(
            password,
            &key_salt,
            constants::KEY_SPIN_COUNT,
            constants::KEY_BITLENGTH,
            &constants::BLOCK_VERIFIER_HASH_INPUT,
        );
        assert_eq!(
            verifier_hash_input_key,
            hex!("44e4b664c512b08e7577aa3fc7e11ad603e0877a476931fad5aa79e203304aff")
        );

        let encrypted_verifier_hash_input =
            crypt(true, &verifier_hash_input_key, &key_salt, &verifier_hash_input).unwrap();
        // Uncomment the following lines to check the encrypted verifier hash input
        // let converted = encode_hex(&encrypted_verifier_hash_input);
        // assert_eq!(&converted, "2fb9eea58e227ffa549449e941f1199e");

        // Verifier hash value
        let verifier_hash_value = hash_concatenated(&[&verifier_hash_input]);
        // Uncomment the following lines to check the verifier hash value
        // let converted = encode_hex(&verifier_hash_value);
        // assert_eq!(&converted,
        // "920b1de74f38d9cb3ccb3394119ed37e958404fdc47560b1bf647d3c49c22549625fe4a0bd36798bd68a0d98ae64f6ab64a330c9890c62bb740aa492c226ae1f"
        // );

        let verifier_hash_value_key = convert_password_to_key(
            password,
            &key_salt,
            constants::KEY_SPIN_COUNT,
            constants::KEY_BITLENGTH,
            &constants::BLOCK_VERIFIER_HASH_VALUE,
        );
        // Uncomment the following lines to check the verifier hash value key
        // let converted = encode_hex(&verifier_hash_value_key);
        // assert_eq!(
        //     &converted,
        //     "d5515a6062e3e99551b80b92db1fe646483884cdb63e1e7595a9f2cca7532884"
        // );

        let encrypted_verifier_hash_value =
            crypt(true, &verifier_hash_value_key, &key_salt, &verifier_hash_value).unwrap();
        // Uncomment the following lines to check the encrypted verifier hash value
        // let converted = encode_hex(&encrypted_verifier_hash_value);
        // assert_eq!(
        //     &converted,
        //     "0d9c888111b40b630b739c95a5f5b6be67c8f96acdd1bee185bd808b507f652760a2e77f63a6ad0c46f985f2bb8dab4fcf9b86d6a40d9c21299bb4ddf788b250"
        // );

        // Build encryption info
        let _unused = build_encryption_info(
            &package_salt,
            &encrypted_hmac_key,
            &encrypted_hmac_value,
            &key_salt,
            &encrypted_verifier_hash_input,
            &encrypted_verifier_hash_value,
            &encrypted_key_value,
        );
    }

    #[test]
    fn test_hash() {
        let package_salt = hex!("4c251b321d85cecfcb6d952ba6d81846");
        let result =
            hash_concatenated(&[&package_salt, &constants::BLOCK_KEYS_DATA_INTEGRITY_HMAC_KEY]);
        assert_eq!(
            result,
            hex!(
                "ba1bf00eed82b07ee65e574eb1f460435d2a1405e81904fd01d5ed5adf43fdcf
                 d8e9aeebad0c08065e0db20cdc8e4552744b61ad1b3cf9a3c5aad5b2a047e76b"
            )
        );
    }

    #[test]
    fn test_buffer_slice() {
        // Since buffer_slice is not defined in the new code, we can replicate its
        // functionality inline
        let buffer = hex!(
            "ba1bf00eed82b07ee65e574eb1f460435d2a1405e81904fd01d5ed5adf43fdcf
             d8e9aeebad0c08065e0db20cdc8e4552744b61ad1b3cf9a3c5aad5b2a047e76b"
        );
        let start = 0;
        let end = 16;
        let result = buffer[start..end].to_vec();
        assert_eq!(result, hex!("ba1bf00eed82b07ee65e574eb1f46043"));
    }

    #[test]
    fn test_convert_password_to_key() {
        let key_salt = hex!("3aa973eec73c98c4710021730ef5b513");
        let result = convert_password_to_key(
            "password",
            &key_salt,
            100_000,
            256,
            &constants::BLOCK_KEYS_KEY,
        );
        assert_eq!(
            result,
            hex!("8d5869311b1c1fdb59a1de6fe1e6f2ce7dccd4deb198a6dfb1f7fb55bc03487d")
        );
    }
}
